{
  "summary": "",
  "format": {
    "id": "953",
    "duration": "PT40m",
    "title": "Conference"
  },
  "title": "A Java 8 lambda is all you need for distributed background jobs!",
  "speakers": [
    {
      "photoUrl": "https://lh3.googleusercontent.com/a-/AOh14GjAnq6BY--6_1G6cMV21ieYaZM0_lxaokhbDC7RBMs=s96-c",
      "companyName": "JobRunr",
      "fullName": "Ronald Dehuysser",
      "id": "3957"
    }
  ],
  "language": "EN",
  "track": {
    "title": "Server Side Java",
    "id": "1256"
  },
  "description": "<p>Do you need to perform some CPU heavy tasks? Or some work that requires a lot of I/O? Or do you just need to run or schedule some background jobs without blocking the rest of your system? I often see teams building a scheduling solution themselves, severely underestimating the complexity of running jobs asynchronously. A costly endeavour, especially with a simple, free and open-source solution readily available.</p><p>&nbsp;</p><p>During this humoristic session, I will introduce you to JobRunr: the ultimate library for background processing in Java. By transforming Java 8 lambdas into distributed background tasks, JobRunr allows you to run any job at anytime and on any JVM. We’ll go over the different functionalities like job&nbsp;persistence,&nbsp;automatic retries, scaling up (hello k8s) and the embedded dashboard to give you a good grasp of the possibilities.&nbsp;Oh, and did you know it also works on GraalVM?</p><p>&nbsp;</p><p>After this session, you’ll have a good idea of what JobRunr is, how it does it's magic and how it&nbsp;will allow you to focus on delivering value to your end users instead of implementing scheduling over and over again.</p>",
  "id": "4060",
  "room": {
    "title": "Skalkotas",
    "id": "2802"
  }
}