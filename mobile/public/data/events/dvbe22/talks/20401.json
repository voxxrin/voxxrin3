{
  "room": {
    "id": "4709",
    "title": "Room 9"
  },
  "format": {
    "id": "951",
    "title": "Conference",
    "duration": "PT50m"
  },
  "language": "EN",
  "speakers": [
    {
      "companyName": "Red Hat",
      "photoUrl": "https://lh3.googleusercontent.com/a-/AOh14GihCBYp1plXFDKfAchzpn7tZkBlhGUg3kD7xvlSjw=s96-c",
      "fullName": "Gunnar Morling",
      "id": "20089"
    }
  ],
  "track": {
    "id": "1252",
    "title": "Data & AI"
  },
  "title": "Keep Your Cache Always Fresh with Debezium!",
  "summary": "Learn how to keep read views of your data in distributed caches close to your users, always kept in sync with your primary data stores.",
  "description": "<p>The saying goes that there are only two hard things in Computer Science: cache invalidation, and naming things. Well, turns out the first one is solved actually ;)</p><p>Join us for this session to learn how to keep read views of your data in distributed caches close to your users, always kept in sync with your primary data stores change data capture. You will learn how to</p><p>- Implement a low-latency data pipeline for cache updates based on Debezium, Apache Kafka, and Infinispan</p><p>- Create denormalized views of your data using Kafka Streams and make them accessible via plain key look-ups from a cache cluster close by</p><p>- Propagate updates between cache clusters using cross-site replication</p><p>We'll also touch on some advanced concepts, such as detecting and rejecting writes to the system of record which are derived from outdated cached state, and show in a demo how all the pieces come together, of course connected via Apache Kafka.</p>",
  "id": "20401"
}