{
  "room": {
    "title": "Room 9",
    "id": "4709"
  },
  "summary": "In this session, you will learn how to redesign your Kubernetes autoscaling architecture by event-driven metrics from Apache Kafka over standard resources (CPU, Memory) with Knative and KEDA integration for serverless Java using Quarkus.",
  "track": {
    "id": "1701",
    "title": "Development Practices"
  },
  "speakers": [
    {
      "id": "3902",
      "photoUrl": "https://devoxxian-image-thumbnails.s3-eu-west-1.amazonaws.com/profile-1a62f608-5d7a-46aa-82df-dffb52d6f248.jpeg",
      "fullName": "Daniel Oh",
      "companyName": "Red Hat"
    }
  ],
  "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Kubernetes makes it possible to autoscale various business use cases from the web apps to mobile, IoT edge streaming, and AI/ML in more reliable and stable ways. One caveat of the Kubernetes autoscaling is based on hardware resource utilization (CPU, memory) through Horizontal Pod Autoscaling. This causes a new challenge to build an event-driven serverless Java on Kubernetes because the event metrics from multiple event sources (e.g., Apache Kafka, AWS SQS) are more relevant than a pod's CPU usage for deciding when applications need to be scaled out and in.&nbsp;</span></p><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Fortunately, KEDA and Knative on Kubernetes are designed to solve this challenge by autoscaling both standard apps and serverless by event metrics in a separate way. This session will teach you how to redesign your Kubernetes autoscaling architecture by event-driven metrics from Apache Kafka over standard resources (CPU, Memory) with Knative and KEDA integration for serverless Java using Quarkus.</span></p><p><br></p>",
  "format": {
    "title": "Conference",
    "id": "951",
    "duration": "PT50m"
  },
  "title": "Event-driven autoscaling for Serverless Java",
  "language": "EN",
  "id": "3954"
}