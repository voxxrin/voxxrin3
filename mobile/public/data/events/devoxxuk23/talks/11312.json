{
  "format": {
    "id": "960",
    "title": "Byte Size",
    "duration": "PT15m"
  },
  "speakers": [
    {
      "photoUrl": "https://devoxxian-image-thumbnails.s3-eu-west-1.amazonaws.com/profile-b22c81e5-7e5f-43d6-8d02-f4be5de151ec.jpeg",
      "fullName": "Yarden Laifenfeld",
      "companyName": "Rookout",
      "id": "5549"
    }
  ],
  "id": "11312",
  "room": {
    "id": "19155",
    "title": "Room D"
  },
  "language": "EN",
  "description": "<p>I’m guessing that Go wasn’t your first programming language. When you started to learn Go you probably thought to yourself that structs are like classes, and that embedding a struct is like inheriting from a class - I know that I did. Now, while that’s a good way to start learning Go’s concepts, using embedded structs as inheritance in Go code is problematic and may lead to design flaws, and, worse, to buggy code.</p><p><br></p><p>On the other hand, there’s a reason almost all high level programming languages have inheritance - it’s a good way to reuse code and to extend the behavior of external libraries. So, what’s the right way to reach these goals in Go?</p><p><br></p><p>In order to answer this question, we need to understand the difference between a struct in Go and a class in a high level language. This talk will focus on Go’s relationship with inheritance, but along the way we’ll also discuss our process of thought when designing a Go program, from what structs we create, to which interfaces they implement and the relationship between different types in our code.</p><p>A good Go developer is not one that has perfected the syntax, but one that knows how to use the language’s mechanisms to improve their code. Hopefully, by the end of this talk, you will gain deeper insight into Go’s alternatives to inheritance and have some practical tools to help you use them in your code.</p>",
  "summary": "",
  "title": "From OOP to Go",
  "track": {
    "id": "1401",
    "title": "Programming Languages"
  }
}